
/* Kernel includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "pub_def.h"

/* Processor expert includes. */
#include "SW1Int.h"

/*-----------------------------------------------------------
	Definitions.
-----------------------------------------------------------*/

/* Priorities assigned to demo application tasks. */
#define RADIO_PRIORITY			( tskIDLE_PRIORITY + 2 )
#define RADIO_QUEUE_SIZE		10

/*-----------------------------------------------------------
	Local functions prototypes.
-----------------------------------------------------------*/

// The 'Button Push' task.  See the explanation at the top of the file.
static void vRadioTransmitTask( void *pvParameters );
static void vRadioReceiveTask( void *pvParameters );
static void vLEDBlinkTask( void *pvParameters );
void LEDOn(int inLED);
void LEDOff(int inLED);


/*-----------------------------------------------------------
	Local variables.
-----------------------------------------------------------*/

/* The queue used to send data from the radio to the radio receive task. */
static xQueueHandle xRadioTransmitQueue;
static xQueueHandle xRadioReceiveQueue;
static xQueueHandle xLEDBlinkQueue;

UINT8 gu8RTxMode;
UINT8 gLED1 = 1;
UINT8 gLED2 = 2;
UINT8 gLED3 = 3;
UINT8 gLED4 = 4;

/*-----------------------------------------------------------*/

/* 
 * This is called from the main() function generated by the Processor Expert.
 */
void vMain( void )
{
	tRxPacket gsRxPacket;
	tTxPacket gsTxPacket;
	UINT8 gau8RxDataBuffer[8];
	UINT8 gau8TxDataBuffer[8];
	UINT8 u8RetryNo = 0;
	UINT16 u16Count = 0;

	/* Initialize the packet.*/
	gsTxPacket.u8DataLength = 0;
	gsTxPacket.pu8Data = &gau8TxDataBuffer[0];
	gsRxPacket.u8DataLength = 0;
	gsRxPacket.pu8Data = &gau8RxDataBuffer[0];
	gsRxPacket.u8MaxDataLength = 8;
	gsRxPacket.u8Status = 0;

	MCUInit();
	MC13192Init();
	MLMESetMC13192ClockRate(0);
#ifdef XBEE
	xbeeInit();
#endif

	MLMEMC13192PAOutputAdjust(MAX_POWER);    //Set MAX power setting

	if (MLMESetChannelRequest(15) == SUCCESS) {
	}

	/* Start the task that will handle the radio */
	xTaskCreate( vRadioTransmitTask, "RadioTransmit", configMINIMAL_STACK_SIZE, NULL, RADIO_PRIORITY, NULL );
	xTaskCreate( vRadioReceiveTask, "RadioReceive", configMINIMAL_STACK_SIZE, NULL, RADIO_PRIORITY, NULL );
	xTaskCreate( vLEDBlinkTask, "LED Blink", configMINIMAL_STACK_SIZE, NULL, RADIO_PRIORITY, NULL );
	
	/* All the tasks have been created - start the scheduler. */
	vTaskStartScheduler();
	
	/* Should not reach here! */
	for( ;; );
}

/*-----------------------------------------------------------*/

static void vRadioTransmitTask( void *pvParameters )
{
	tTxPacket gsTxPacket;
	tRxPacket gsRxPacket;
	UINT8 gau8TxDataBuffer[16] = APPNAME;
	UINT8 gau8RxDataBuffer[16];
	
	byte	*msgP;

	gsRxPacket.u8MaxDataLength = 0;
	gsRxPacket.pu8Data = &gau8RxDataBuffer[0];
	gsRxPacket.u8MaxDataLength = 16;    /* Arbitrary, bigger than xXyYzZ format. */
	gsRxPacket.u8Status = 0;                /* initialize status to 0. */

	gsTxPacket.pu8Data = &gau8TxDataBuffer[0]; /* Set the pointer to point to the tx_buffer */

	xRadioTransmitQueue = xQueueCreate(RADIO_QUEUE_SIZE, (unsigned portBASE_TYPE) sizeof(unsigned portBASE_TYPE));

	for( ;; )
	{
		gsTxPacket.u8DataLength = 4;    /* Initialize the gsTxPacket global */
		MCPSDataRequest(&gsTxPacket);
		
		if(xQueueSend( xLEDBlinkQueue, &gLED1, pdFALSE )) {
		}

		MLMERXEnableRequest(&gsRxPacket, 0L);
		if( xQueueReceive( xRadioTransmitQueue, &msgP, portTICK_RATE_MS * 1000 ) == pdPASS ) {
			vTaskDelay(portTICK_RATE_MS * 100);
		}
		MLMERXDisableRequest();
	}
	
}

/*-----------------------------------------------------------*/

static void vRadioReceiveTask( void *pvParameters )
{
	byte	*packetDataP;

	// The radio receive task will return a pointer to a radio data packet.
	
	/* Create the queue used by the producer and consumer. */
	xRadioReceiveQueue = xQueueCreate(RADIO_QUEUE_SIZE, (unsigned portBASE_TYPE) sizeof(unsigned portBASE_TYPE));
	initMC13191(xRadioReceiveQueue);
	
	if( xRadioReceiveQueue )
	{
		/* Now the queue is created it is safe to enable the radio receive interrupt. */
		SW1Int_Enable();
	
		for( ;; )
		{
			/* Simply wait for data to arrive from the button push interrupt. */
			if( xQueueReceive( xRadioReceiveQueue, &packetDataP, portMAX_DELAY ) == pdPASS ) {
				if(xQueueSend( xLEDBlinkQueue, &gLED2, pdFALSE )) {
				}
						
				if(xQueueSend( xRadioTransmitQueue, NULL, pdFALSE )) {
				}		

			}
		}
	}
	
	/* Will only get here if the queue could not be created. */
	for( ;; );		
}

/*-----------------------------------------------------------*/

static void vLEDBlinkTask( void *pvParameters )
{
	UINT8	ledNum;

	xLEDBlinkQueue = xQueueCreate(RADIO_QUEUE_SIZE, (unsigned portBASE_TYPE) sizeof(unsigned portBASE_TYPE));
	
	if( xLEDBlinkQueue )
	{
		for( ;; )
		{
			/* Simply wait for data to arrive from the button push interrupt. */
			if( xQueueReceive( xLEDBlinkQueue, &ledNum, portMAX_DELAY ) == pdPASS ) {
				LEDOn(ledNum);
				vTaskDelay(portTICK_RATE_MS * 100);
				LEDOff(ledNum);	
			}
		}
	}
	
	/* Will only get here if the queue could not be created. */
	for( ;; );		
}

/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
	/* Yield in case cooperative scheduling is being used. */
	#if configUSE_PREEMPTION == 0
	{
		taskYIELD();
	}
	#endif		
}

/*-----------------------------------------------------------*/

void LEDOn(int inLEDNum)
{
	switch (inLEDNum) {
	
		case 1:
		//	LED1_ClrVal();
			break;
	
		case 2:
		//	LED2_ClrVal();
			break;
	
		case 3:
		//	LED3_ClrVal();
			break;
	
		case 4:
		//	LED4_ClrVal();
			break;
	
	}
}

/*-----------------------------------------------------------*/

void LEDOff(int inLEDNum)
{
	switch (inLEDNum) {
	
		case 1:
		//	LED1_SetVal();
			break;
	
		case 2:
		//	LED2_SetVal();
			break;
	
		case 3:
		//	LED3_SetVal();
			break;
	
		case 4:
		//	LED4_SetVal();
			break;
	
	}
}
